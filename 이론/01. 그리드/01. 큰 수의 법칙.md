### 내가 푼 파이썬 코드 
---
``` python
N, M, K = map(int, input().split())  
data = list(map(int,input().split()))  
  
data.sort(reverse=True)  
ans = 0  
  
while True:  
	if M == 0:  
		break  
	for k in range(K):  
		ans += data[0]  
		M -= 1  
	ans += data[1]  
	M -= 1  
  
print(ans)
```


### 내가 푼 C++ 코드 
---
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	int N, M, K;
	int ans = 0;
	cin >> N >> M >> K;
	vector<int> data;
	for (int i = 0; i < N; i++) {
		int x;
		cin >> x;
		data.push_back(x);
	}
	sort(data.begin(), data.end(), greater<int>());

	while (M != 0) {
		for (int i = 0; i < K; i++) {
			ans += data[0];
			M--;
		}
		ans += data[1];
		M--;
	}

	cout << ans;
}
```

임시객체로 인한 호출 방법을 썼다. `sort(data.begin(), data.end(), greater<int>());`

임시객체로 인한 호출
-  만약 클래스 `Temporary`가 있다고 치자 그럼 임시객체를 직접 생성하는 방법은 `Temporary<int>()` 으로 부를 수 있다.


### 내가 푼 java 코드
---
``` java
import java.util.*;

public class Test {
    public static void main(String args[]) {
        int N, M, K;
        int ans = 0;
        Vector<Integer> vc = new Vector<Integer>(); // Integer를 명시해야 합니다.
        Scanner sc = new Scanner(System.in);

        N = sc.nextInt();
        M = sc.nextInt();
        K = sc.nextInt();

        for (int i = 0; i < N; i++) {
            int x = sc.nextInt();
            vc.add(x);
        }

        Collections.sort(vc, Collections.reverseOrder()); // 내림차순으로 정렬합니다.

        while (M != 0) {
            for (int i = 0; i < K; i++) {
                ans += vc.get(0); // 가장 큰 값을 사용해야 합니다.
                M--;
            }
            ans += vc.get(1); // 두 번째로 큰 값을 추가합니다.
            M--;
        }

        System.out.println(ans); // 결과를 출력합니다.
    }
}

```


# 문제 해설
---
이 문제는 `반복되는 수열`에 관한 문제이다.

가장 큰 수가 6, 두 번째로 큰 수가 5라고 하자, 이때 M = 8이고 K=3이라면 한번 반복되는 수열은 다음과 같다.

| 반복되는 수열 | 6   | 6   | 6   | 5   |
| ------------- | --- | --- | --- | --- |
반복되는 수열의 길이는 4이며 이는 K+1이다.

따라서 M을 K+1로 나눈 값이 반복되는 횟수(e)가 된다. 이때 반복되는 횟수에 한번 반복되었을때 가장 큰 수가 등장한 횟수 K를 곱하면 가장 큰 수가 더해진 횟수가 된다. 

이때 만약 M이 K+1로 나누어 떨어지지 않는다면 남은 만큼 또 큰 수가 더해진다. 따라서 이를 고려해야 한다.

따라서 가장 큰 수가 나타날 횟수는 다음과 같다.

```
int(M / (K+1)) * K + (M % (K+1))
```

따라서 더 나은 알고리즘은 다음과 같다.

``` python
# N, M, K를 공백을 기준으로 구분하여 입력 받기
n, m, k = map(int, input().split())
# N개의 수를 공백을 기준으로 구분하여 입력 받기
data = list(map(int, input().split()))

data.sort() # 입력 받은 수들 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

# 가장 큰 수가 더해지는 횟수 계산
count = int(m / (k + 1)) * k + (m % (k + 1))

result = 0
result += (count) * first # 가장 큰 수 더하기
result += (m - count) * second # 두 번째로 큰 수 더하기

print(result) # 최종 답안 출력
```

