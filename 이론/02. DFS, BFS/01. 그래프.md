그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고도 한다.

그래프는 크게 2가지 방식으로 표현할 수 있다.
1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
2. 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

### 1. 인접 행렬
---
![[Pasted image 20240306152309.png|500]]

인접 행렬은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다. 

``` python
INF = 99999999

graph = [
	[0, 7, 5],
	[7, 0, INF],
	[5, INF, 0]
]
```

``` cpp
#define INF 999999999 // 무한의 비용 선언 
using namespace std; // 2차원 리스트를 이용해 인접 행렬 표현 

int graph[3][3] = { 
	{0, 7, 5}, 
	{7, 0, INF}, 
	{5, INF, 0} 
}; 

int main(void) { // 그래프 출력 
	for (int i = 0; i < 3; i++) { 
		for (int j = 0; j < 3; j++) { 
			cout << graph[i][j] << ' ';
		} 
		cout << '\n'; 
	} 
}
```


### 2. 인접 리스트
---
![[Pasted image 20240306152647.png]]

모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장된다.

``` python
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장 (노드, 거리)
graph[1].append((0,7))

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[2].append((0, 5))
```

``` cpp
using namespace std; 
// 행(Row))이 3개인 인접 리스트 표현
vector<pair<int, int>> graph[3];

int main(void) { 
	// 노드 0에 연결된 노드 정보 저장 {노드, 거리} 
	graph[0].push_back({1, 7}); 
	graph[0].push_back({2, 5});

	// 노드 1에 연결된 노드 정보 저장 {노드, 거리} 
	graph[1].push_back({0, 7}); 
	
	// 노드 2에 연결된 노드 정보 저장 {노드, 거리} 
	graph[2].push_back({0, 5}); 
	
	// 그래프 출력 
	for (int i = 0; i < 3; i++) { 
		for (int j = 0; j < graph[i].size(); j++) { 
			cout << '(' << graph[i][j].first << ',' << graph[i][j].second << ')' << ' '; 
			} 
		cout << '\n'; 
	} 
}
```

### 3. 장단점
---
![[Pasted image 20240306160135.png]]


