### 1. 인접 행렬? 인접 그래프?
---
가장 큰 의문이 바로 이거다. 여태껏 우리가 만든 구현 방법은 인접 그래프를 이용한 것이었다. 위 맵을 어떻게 인접 그래프로 나타내야 할지 막막했다.

사실 이 문제는 예전에 해결을 했다. 바로 맵을 형성하는 상하좌우 문제이다.

![[Pasted image 20240309200317.png|400]]

이 문제의 핵심은 맵을 직접 디자인한다가 아니라 `가이드 라인`의 설정임을 기억하자. 따라서 다음의 순서로 문제풀이를 진행해야 한다. 

1. 맵이니까 인접 행렬로 구성한다.
2. 탐색중 맵 외부로 나가는것을 막기 위해 최소한의 가이드라인을 제시한다.
3. 이동 경로는 DFS, BFS로 설정한다

### 2. 맵을 어떻게 받지?
---
C++의 배열은 문제가 하나 있다. 바로, 배열의 선언에는 변수가 들어갈 수 없다는 것이다. (정적 메모리 할당 정책 떄문). 그럼 동적 메모리 할당을 하면 될까? 이 부분이 궁금했다.

정답은 다음과 같다.
``` cpp
int n, m;
int graph[1000][1000];
```

그렇다. 문제에서 주어진 최대 길이를 기준으로 생성해두면 된다. 근데 그럼 주어진 메모리 제한이 넘지 않을까? 싶을 수 있다.

한번 사용하는 메모리를 계산해보자. 일반적으로 `int`는 4바이트(32비트 시스템과 64비트 시스템 모두에서)를 차지한다. 따라서 `int graph[1000][1000];`의 총 메모리 사용량은 다음과 같이 계산할 수 있다.

`메모리 사용량 = 1000 × 1000 × 4바이트`

따라서  `int graph[1000][1000];` 배열은 메모리를 약 4,000,000바이트(바이트 단위) 또는 대략 3.81메가바이트(MB)를 차지한다. ​충분하단 의미이다. 

그리고 어차피 이동하지 못하는 곳에는 0으로 표기해줄것이므로 안심하고 이렇게 사용하자!


### 3. 맵의 입력 방법
---
그리고 맵의 입력의 경우 공백없이 연달아 입력되는 경우가 많다.

다시 말해
``` 
00110
00011
11111
00000
```

이 입력되는 경우 `cin`의 사용은 불가능하다. `cin`은 공백을 기준으로 데이터간 경계가 생기기 때문이다. 따라서 다음과 같이 입력을 받아야 한다. 

``` cpp
// 2차원 리스트의 맵 정보 입력 받기
for (int i = 0; i < n; i++) {
	for (int j = 0; j < m; j++) {
		scanf("%1d", &graph[i][j]);
	}
}
```

### 4. 행동 양식
---
이전에 코딩해봤던 DFS, BFS는 모두 인접 리스트를 기반으로 처리했다. 그럼 인접 행렬의 경우에는 어떻게 해야 하는가?

사실 두 놈 다 퍼지는 형식으로 처리하긴 한다. 하지만 다른게 있다면 바로 작동하는 방식이다!

##### DFS는 다음과 같다. 

![[Pasted image 20240309230556.png]]
``` cpp
bool dfs(int x, int y) {
    // 주어진 범위를 벗어나는 경우에는 즉시 종료
    if (x <= -1 || x >=n || y <= -1 || y >= m) {
        return false;
    }
    // 현재 노드를 아직 방문하지 않았다면
    if (graph[x][y] == 0) {
        // 해당 노드 방문 처리
        graph[x][y] = 1; // 방문 처리가 여기있으니 주의!!!!!!!
        // 상, 하, 좌, 우의 위치들도 모두 재귀적으로 호출
        dfs(x - 1, y); // 경로 1번을 재귀적으로 끝까지 감
        dfs(x, y - 1); // 경로 2번을 재귀적으로 끝까지 감
        dfs(x + 1, y); // 경로 3번을 재귀적으로 끝까지 감
        dfs(x, y + 1); // 경로 4번을 재귀적으로 끝까지 감
        return true;
    }
    return false;
}
```

즉, 일정 경로로 끝까지 가고 그 다음 경로를 탐색하게 된다. DFS의 이름 그대로 "깊이 우선 탐색" 이다.  저 `start`지점을 다양한 위치에 배치하면 (모든 맵을 탐색하고 싶으면 그냥 모든 맵을 방문하게 하면 된다.) 된다. 

##### BFS는 다음과 같다.

![[Pasted image 20240309231626.png]]
``` cpp
int bfs(int x, int y) {
    // 큐(Queue) 구현을 위해 queue 라이브러리 사용 
    queue<pair<int, int> > q;
    q.push({x, y});
    // 큐가 빌 때까지 반복하기 
    while(!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        // 현재 위치에서 4가지 방향으로의 위치 확인
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            // 미로 찾기 공간을 벗어난 경우 무시
            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            // 벽인 경우 무시
            if (graph[nx][ny] == 0) continue;
            // 해당 노드를 처음 방문하는 경우에만 최단 거리 기록
            if (graph[nx][ny] == 1) {
                graph[nx][ny] = graph[x][y] + 1;
                q.push({nx, ny});
            } 
        } 
    }
    // 가장 오른쪽 아래까지의 최단 거리 반환
    return graph[n - 1][m - 1];
}
```

BFS(너비 우선 탐색)이라는 이름에 맞게, 점점 퍼지는 형식을 취하고 있다. DFS와 다르게 BFS는 한번만 시작 위치를 정해주면 알아서 퍼져 나가기 때문에 알고리즘을 다시 실행할 필요가 없다.


### 5. 알고리즘 차이점
---
##### DFS
1. 맵이니까 인접 행렬로 구성한다.
2. 탐색중 맵 외부로 나가는것을 막기 위해 최소한의 가이드라인을 제시한다.
3. 노드를 방문하지 않았다면, 방문처리하고, 왼쪽, 아래, 오른쪽, 위 순으로 재귀적으로 끝까지 가도록 한다

##### BFS
1. 맵이니까 인접 행렬로 구성한다.
2. 큐에 현 데이터를 넣는다. 큐에 담긴 데이터를 기준으로 주변으로 이동해본다.
3. 탐색중 맵 외부로 나가는것을 막기 위해 최소한의 가이드라인을 제시한다.
4. 왼쪽, 아래, 오른쪽, 위 순으로 노드를 각각 이동한뒤 방문하지 않는 노드를 큐에 넣는다 


### 4. 언제 쓰는가?
---
##### 1. DFS를 써야하는 경우
1. 맵의 이곳 저곳을 돌아다니면서 탐색을 해야할 경우. 즉, 특정 경로를 선택해줘야 하는 경우

##### 2. BFS를 써야하는 경우
1. 모든 맵을 단 한번의 실행으로 탐색해야 하는 경우. 즉, 특정 경로에 상관없이 탐색해야 하는 경우
