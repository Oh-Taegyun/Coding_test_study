> 출처 : https://velog.io/@sisofiy626/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-2.-%EC%8A%A4%ED%83%9DStack%EA%B3%BC-%ED%81%90Queue-%EB%8D%B1Deque

오늘은 선형 자료구조에 해당하는 자료구조 중 대표적인 스택, 큐, 덱 3가지의 자료구조에 대해서 알아보겠습니다.

### 1. 스택 (Stack)
---
![](https://velog.velcdn.com/images/sisofiy626/post/903c827f-6595-49d0-a311-837b0311b30b/image.png)

스택은 가장 마지막에 저장된 데이터가 가장 먼저 삭제되는 **후입선출(LIFO, Last In First Out) 구조**입니다.  스택은 한쪽 방향에서만 데이터의 삽입과 삭제가 가능합니다.

##### **스택 용어**
- top(peek): 가장 최근에 저장된 데이터이자 먼저 삭제 될 데이터입니다. 그림상에서 요소 4가 해당됩니다.
- push: 데이터를 삽입하는것을 말하며 삽입 된 데이터는 삭제시 가장 먼저 삭제 될 데이터가 됩니다.
- pop: 데이터를 삭제할 때 사용하며 가장 최근에 저장된 데이터가 삭제됩니다.

##### **사용되는 예**
- 브라우저의 뒤로가기
- 실행 취소 (Ctrl + z)
- 재귀 함수
- 역순 문자열 (문자열 거꾸로 뒤집기)

스택의 자료구조는 삽입과 삭제시에 O(1), 탐색에는 O(n)의 시간복잡도를 가지게 됩니다.

### 2. 큐(Queue)

![](https://velog.velcdn.com/images/sisofiy626/post/ec98d0ca-51c7-4485-8e72-638a7402eee3/image.png)

큐는 위에서 설명한 스택과는 달리 한 쪽에서는 데이터 삽입, 다른 한 쪽에서는 데이터의 삭제만 가능한 **선입선출(FIFO, First In First Out) 구조**를 가지고 있습니다.

실생활에서는 재료의 선입선출(유통기한이 오래된 것을 가장 앞쪽에 배치), 식당의 줄서기 등이 대표적인 예입니다.

##### **큐 용어**
- Enqueue: 데이터 삽입
- Dequeue (JS의 shift): 데이터 삭제
- Front: Dequeue시 삭제되는 데이터 (가장 먼저 저장된 데이터)를 가르킵니다.
- Rear: 추가될 새로운 요소의 위치를 가르킵니다.

##### **사용되는 예**
- BFS 알고리즘
- 프로세스 관리 (JS의 콜백 큐)
- 프린터의 대기열

큐에는 우선순위 큐, 원형 큐라는 2개의 종류가 더 있기 때문에 지금 설명하는 큐는 **선형 큐(Linear Queue)라고도 부릅니다.**

큐는 스택과 마찬가지로 삽입과 삭제에는 O(1), 탐색에는 O(n)의 시간복잡도를 가집니다.

### 3. 큐의 다른 종류
---
##### 우선순위 큐 (Priority Queue)
![](https://velog.velcdn.com/images/sisofiy626/post/bda424e6-981a-4801-9ac8-f7e9dccf495f/image.png)

우선순위 큐의 각 요소는 값과 우선순위, 총 2개의 데이터를 가지고 있습니다.

따라서 선형큐와는 달리 우선순위가 높은 요소일수록 먼저 삭제되는 특징을 가지고 있으며 우선순위가 같은 데이터일 경우 삽입순서를 따릅니다.

삽입 및 삭제 시 우선순위에 따라 요소들을 정렬 해야하기 때문에 주로 힙(Heap)이라는 자료구조로 구현되며  

실생활에서 병원의 응급실에서는 응급 환자가 우선 순위가 높으므로 먼저 진료를 받고 일반 환자는 순서가 뒤로 밀리는것과 같은 맥락입니다.

우선순위 큐는 어떻게 구현하느냐에 따라 시간복잡도가 달라지지만 힙을 기준으로 한다면 삽입과 삭제에는 O(logn), 우선순위가 가장 높은 요소를 탐색할 때는 O(1)만큼의 시간복잡도를 가집니다.



---

 **큐 (Queue)**
- 데이터를 임시 저장할 때 사용한다.
- 데이터가 rear에서 삽입되고, front에서 삭제된다.
- 선입선출 방식이다. 가장 먼저 삽입된 데이터가 가장 먼저 삭제된다.
- front : 데이터를 삭제하는 부분
- rear : 데이터를 삽입하는 부분
- enqueue : 데이터를 삽입하는 작업
- dequeue : 데이터를 삭제하는 작업

![](https://blog.kakaocdn.net/dn/VwUUR/btq8sorJJvn/OfiJosvtiJyliz0YInsQ2K/img.png)

**● 선형 큐 (Linear Queue)**
- 1차원 배열을 이용해 큐를 구현한다.

![](https://blog.kakaocdn.net/dn/C52Zu/btq8spjR8uw/SouCpYhYKqyTWOCbKRSzek/img.png)

- 문제점 : 앞에 자리가 있음에도 불구하고 포화상태로 인식하는 경우가 있다.

![](https://blog.kakaocdn.net/dn/cXXkz4/btq8rTFxxqe/x6uKzsplg83tbM2Z2KBtak/img.png)

**● 원형 큐 (Circular Queue)**

- 1차원 배열을 이용해 큐를 구현한다.

- 선형 큐의 문제점을 보완하고자 나왔다. -> rear mod queue_size, front mod queue_size

![](https://blog.kakaocdn.net/dn/JQR4l/btq8spYvz6J/RJQyblMCO6qiwCaK2foGf1/img.png)

**● 연결 큐 (Linked List Queue)**

- 단순 연결 리스트를 이용해 큐를 구현한다.

![](https://blog.kakaocdn.net/dn/beL2dJ/btq8rXgL9aj/u3lt0y5rltc35z2fUQe7Rk/img.png)

**● 데크 (Double-Ended Queue)**

- 큐 두 개중 하나를 좌우로 뒤집어서 붙인 구조다.

- 데이터가 front&rear에서 삽입&삭제된다.

- 양방향으로 연산이 가능한 이중 연결 리스트를 이용하여 구현하는 것이 효율적이다.

○ 삽입 연산

|   |   |
|---|---|
|Front Enqueue|Rear Enqueue|
|![](https://blog.kakaocdn.net/dn/bkVpt9/btq8rTFAOhz/3wztzHVaw9zJkyBD4csSj1/img.png)|![](https://blog.kakaocdn.net/dn/chFCN2/btq8qIY4xlN/S6LhJoT2B8hH8sDTetsAYK/img.png)|

○ 삭제 연산

|   |   |
|---|---|
|Front Dequeue|Rear Dequeue|
|![](https://blog.kakaocdn.net/dn/xBHFh/btq8rR12I8L/WkWNm2H9GWH9dPWR3kGZfk/img.png)|![](https://blog.kakaocdn.net/dn/YdKK7/btq8pM1KKpP/qlBijHGcQa6kkM3s5TRcb0/img.png)|

