![[08.jpg]]

요약하면 그냥 자료구조를 컬렉션으로 부른다.

1. 컬렉션은 제너릭을 사용한다.
2. int나 double과 같은 기초 자료형은 저장할 수 없고 객체만 가능
3. 기초 자료형을 클래스로 감싼 랩퍼 클래스인 Integer나 Double로 변형
	1. `Vector<int> v = new Vector<int>();` // 컴파일 오류!
	2. `Vector<Integer> v = new Vector<Integer>();` // OK !
4. 오토박싱(auto boxing) - 기본 자료형을 저장하면 자동으로 랩퍼 클래스의 객 체로 변환

![[chapter_13/image/06.png]]


### 1. 컬렉션 인터페이스의 주요 메소드
---
![[chapter_13/image/07.png]]



### 2. 컬렉션의 모든 요소 방문하기
---
1.ArrayList에 문자열 저장했다가 꺼내는 코드
``` java
String a[] = new String[] { "A", "B", "C", "D", "E" }; 
ArrayList<String> arrayList = new ArrayList<>(Arrays.asList(a)); 
	// 배열을 ArrayList 로 변환 
	// List<string> list = Arrays.asList(a); // list.add("F") 등의 메소드 사용 불가
```

2. 전동적인 for 구문을 사용할 수 있다.
``` java
for (int i=0; i< arrayList.size(); i++) // arrayList[i] 사용 불가
	System.out.println(arrayList.get(i)); // get()은 리스트에서 어떤 객체를 가져오는데 사용되는 메소드
```

3. for-each 구문
``` java
for (String s: arrayList) 
	System.out.println(s);
```


### 3. List? ArrayList?
---
java.util.List 는 인터페이스 클래스이며, java.util.Collection 인터페이스를 구현한 것이다. List 를 사용하기 위해서는 아래 클래스들 중 하나로 인스턴스화 할 수 있다.

``` java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
 
List<String> listA = new ArrayList<String>();
List<String> listB = new LinkedList<String>();
List<String> listC = new Vector<String>();
List<String> listD = new Stack<String>();
```

Java에서 `List` 인터페이스는 컬렉션 프레임워크의 일부로, 객체들의 순서 있는 컬렉션을 나타낸다. 

##### List 인터페이스의 주요 특징
1. **순서 보장**: `List`에 추가된 요소들은 삽입된 순서대로 저장됩니다.
2. **중복 허용**: 같은 요소의 중복 저장을 허용합니다.
3. **인덱스 기반 접근**: `List`의 각 요소에는 인덱스가 할당되며, 이를 통해 특정 위치의 요소에 접근할 수 있습니다.

##### 주요 메서드
- `add(E element)`: 리스트의 끝에 요소를 추가합니다.
- `get(int index)`: 지정된 인덱스의 요소를 반환합니다.
- `set(int index, E element)`: 지정된 인덱스에 요소를 설정(교체)합니다.
- `remove(int index)`: 지정된 인덱스의 요소를 제거하고 반환합니다.
- `size()`: 리스트의 크기(요소 수)를 반환합니다.

##### List 구현체
Java에서 `List` 인터페이스는 여러 클래스에 의해 구현됩니다:
- **ArrayList**: 내부적으로 배열을 사용하여 요소를 저장합니다. 요소의 추가 및 접근이 빠릅니다.
- **LinkedList**: 내부적으로 연결 리스트를 사용하여 요소를 저장합니다. 요소의 추가 및 삭제가 빠릅니다.
- **Vector**: `ArrayList`와 유사하지만, 모든 메서드가 동기화되어 있어 멀티스레드 환경에서 안전합니다.

##### 예제
이 예제에서는 `ArrayList`를 사용하여 `List` 인터페이스를 구현하고, 여러 메서드들을 활용해 리스트를 조작하는 방법을 보여줍니다.
``` java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");

        System.out.println("Fruits: " + fruits);
        System.out.println("First fruit: " + fruits.get(0));
        
        fruits.set(1, "Blueberry");
        fruits.remove(2);

        System.out.println("Updated fruits: " + fruits);
    }
}
```


### 4. 반복자
---
C++의 반복자와 다를게 없다.

java.util 패키지에 정의되어 있는 Iterator 인터페이스를 구현하는 객체. Iterator 인터페이스에는 다음 3개의 메소드만 정의되어 있다.

| 메소드    | 설명                                         |
| --------- | -------------------------------------------- |
| hasNext() | 아직 방문하지 않은 원소가 있다면 ture를 반환 |
| next()    | 다음 원소를 반환                             |
| remove()  | 최근에 반환된 원소를 삭제                    |

예제)
``` java
String s;
Iterator e = list.iterator();
while(e.hasNext()) {
	s = (String)e.next();
	System.out.println(s);
}
```

``` java
Iterator<String> iter = arrayList.iterator(); 
String eList; 
while(iter.hasNext()) { 
	eList = iter.next();
	System.out.println(eList); 
}
```